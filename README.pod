=head1 SYNOPSIS

Web automated testing framework.

=head1 Description

=over

=item *

Swat is a powerful and yet simple and flexible tool for rapid web automated testing development.

=item *

=item *

Swat is a web applicaton oriented test framework, this means that it equipes you with nothing more than you need
to automatcaly test your web application, it is light weighted  and easy to use and not burdened by many other "generic" things
that you probably won't use for ever.

=item *

Swat does not carry all heavy load on it's shoulder, with the help of it's "older brother" - curl
swat makes a http requests in a smart way. This means if you know and love curl swat might be easy way to go.
Swat just passes all curl related parameter as is to curl and let curl do it's job.

=item *

Swat is text oriented tool, for good or for bad it does not provide any level of http DOM or xpath hacking, it does
not even try to decouple http headers from body. Actually I<it just returns you a text> where you can find and grep
in old good unix way. Does this sound suspiseosly simple? Sometimes most of things could be tested in a simple way.


=item *
swat is extendable by adding custom perl code, this is where you may add deisred complexity to your test stories.

=item *

And finally swat relies on prover as internal test runner, this has many, many good results:

- swat transparently pass all it's it's arguments to prove which make it simple to adjust swat runner behavior in a prove way
- swat tests might be easily embedded as unit tests into a cpan distributions
- test reports are emitted in a TAP format which are portable and easy to read

=back

Ok, now I hope you are ready to dive into swat tutorial! :)


=head1 Install

    $ sudo apt-get install curl
    $ sudo cpanm swat


Or install from source:

    # useful for contributors and developers
    perl Makefile.PL
    make
    make test
    make install


=head1 Building up swat test harness

Swat test stories always answer on 2 type of questions:

=over

I<What kind of> http request should be send

=item *

I<What kind of> http response should be recieved

=back

As swat is web test oriented tool it deals with some http related stuff as 

=over

=item *

http methods

=item *

http resourses 

=item *

http responses

=back

Swat leverages unix file system to build an I<analogy> for these things:

=head2 HTTP Resources

I<HTTP resourse is just a directory>. You have to create a directory to define a http resourse:

    mkdir foo/
    mkdir -p bar/baz

This code define two http resourses of a tested application - 'foo/' and 'bar/baz'

=head2 HTTP methods

I<HTTP method is just a file>. You have to create a file to define a http method.

    touch foo/get.txt
    touch foo/put.txt
    touch bar/baz/post.txt

It's obvious that `http methods' files should be located at `http resourse' directories.

All the code above defines a three http methods for two http resources:

    - GET /foo
    - PUT /foo
    - POST bar/baz

Here is the list of I<predifened> file names for a http methods files:

    get.txt --> GET method
    post.txt --> POST method
    put.txt --> PUT method
    delete.txt --> DELETE method

=head1 Hostname / IP Address

You need to define hostname or ip address of the application to send request to. The easiest way to do this
is to write hostname or ip address to a file. Swat looks for a file named `host' to get know web application address:

    echo 'app.local' > host


As swat uses curl to make http requests, the host name just need to be compilant with curl requrements, this
for exmaple means you may define a http schema or port here:

    echo 'https://app.local' >> host
    echo 'app.local:8080' >> host

=head2 HTTP Response

Swat makes request to a given http resourses with a given http methods and then validates repsonse.
Swat does this with the help so called I<check lists> defined at http method files.

Check list is just a list of strings the response should match. It might be plain strings or regular expressions matchers:


    echo 200 OK > foo/get.txt
    echo 'Hello I am foo' >> foo/get.txt


The code above defines two test asserts for response returned from `GET /foo':

    - it should contain "200 OK"
    - it should contain "Hello I am foo"

Of cousre as I told you may add some regular expressions checks here:

    echo 'regexp: \d\d\d\d-\d\d-\d\d' >> foo/get.txt


=head1 Swat stories

Bringing all together we have a basic entity for swat test harness - a I<swat story>.

Swat story is a very simple test plan, which could be expressed in a cucumber language as follows:

    Given I have web application 'http://my.cool.app:80'
    And I have http method 'GET'
    And make http request 'GET /foo'
    Then I should response matched '200 OK'
    And I should have response matched 'Hello I am foo'
    And I should have response matched '\d\d\d\d-\d\d-\d\d'

From other hand a swat stories is always 3 related things:

=over

=item *

http method - the method file

=item *

http resourse - the directory where `method file` located in

=item *

check list - the content of method file

=back


=head2 Swat Project


Swat project is sereval related swat stories kept under a single directory. It does not realy matter the name of such a directory,
swat just looks up swat stories files there and then "execute" them ( see L</"Swat to Test::Harness Compilation"> section on how swat executes test stories ).

This is example of a swat project:


    $ tree my/swat/project
    my/swat/project
    |--- host
    |----FOO
    |-----|----BAR
    |           |---- post.txt
    |--- FOO
          |--- get.txt

    3 directories, 3 files

When you ask swat to run swat stories you need to point it a project root directory or `cd' to it and just run swat without arguments:

    swat my/swat/project

    # or

    cd my/swat/project && swat

Note, that project root directory path will be removed from pathes for http resourses during execution:

    - GET FOO
    - POST FOO/BAR


It is possible to run a subset of swat test stories using a C<test_file> variable:

    # run a single test
    test_file=FOO/get swat example/my-app 127.0.0.1

    # run all `FOO/*' stories:
    test_file=FOO/ swat example/my-app 127.0.0.1

Now lets go for swat DSL for describing check lists.

=head1 Check lists

Swat parses http response and try to match it with a next items from the check list:

    # http response
    200 OK
    HELLO
    HELLO WORLD
    My birth day is: 1977-04-16


    # check list
    200 OK
    HELLO
    regexp: \d\d\d\d-\d\d-\d\d


    # swat output
    200 OK matched
    HELLO matched
    regexp: \d\d\d\d-\d\d-\d\d matched

Note, that swat does not care whether more than one lines of response were matched by check list matchers.
It just ok if only one line is matched. However there is possiblity to accumulate all matching lines for further processing, see the L</"captures"> section for this.

Another important thing about check lists is that internally they are represented as Test::More asserts:

=head2 Swat to Test::Harness Compilation

Swat parses swat stories and creates a Test::Harness files to be run under the prove.

Let's we have 3 swat stories:

    user/get.txt # GET /user
    user/post.txt # POST /user
    users/list/get.txt # GET /users/list

As the result of compilation there is 3 Test::Harness test files:

    user/get.t
    user/post.t
    users/get.txt

The swat check list for every swat story is then converted into the list of the Test::More asserts:

    # cat user/get.txt

    200 OK
    regexp: name: \w+
    regexp: age: \d+

    # cat user/get.t

    ok($status,'response matches 200 OK'); # will pass if content includes string '200 OK'
    ok($status,'response matches name: \w+'); # will pass if content has strings matched to /name: \w+/ regexp
    ok($status,'response matches age: \d+'); # etc



Thus swat stories execution consists of two parts:

=over

=item *

B<Compilation phase> where swat stories are converted into Test::Harness format

=item *

B<Execution phase> where test harness tests are executed by prove

=back

Let's get back to DSL for defining check list. Every item of check list is I<string> representing one of four things:


=over

=item *

B<plain string matcher>

    200 OK
    HELLO SWAT
    

=over

=item *

B<regular expression matcher>

Regular expression matchers shpould start with C<regexp:> marker:


    regexp: \d\d\d\d-\d\d-\d\d # date in format of YYYY-MM-DD
    regexp: 20\d # successful http status 200, 201 etc
    regexp: (red|green|blue) # one of three colors
    regexp: App Version Number: \d+\.\d+\.\d+ # version number

You may use C<(>,C<)> to capture subparts of matched strings, the captured chunks will be saved and could be used further, see L</"captures"> section for this.

    regexp: Hello, my name is (\w+)


=item *

B<comments>
    
Comments entries start with C<#> symbol, swat ignore comments chunks when parse swat stories

    # comments could be represented at a distinct line, like here
    200 OK
    Hello World # or could be added to existed matchers to the left, like here


=item *

B<blank lines>


Blank lines found at swat stories files are ignored. You may use blamk lines to improve code readability:

    # check http header
    200 OK
    # then 2 blank lines


    # then another check
    HELLO WORLD


... But you B<can't ignore> blank lines in a C<text block matching> context ( see next point ), use C<:blank_line> marker to match blank lines:

    # :blank_line marker matches blank lines
    # this is especially useful
    # when match in text blocks context:

    begin:
        this line followed by 2 blank lines
        :blank_line
        :blank_line
    end:


=item *

B<matching text blocks>

Sometimes it is very helpful to match a reponse against a C<block of strings> goes consequentially, like here:


    # this text block
    # consists of 5 strings
    # goes consequentially
    # line by line:

    begin:
        # plain strings
        this string followed by
        that string followed by
        another one
        # regexps patterns:
    regexp: with (this|that)
        # and the last one in a block
        at the very end
    end:

This test will pass when running against this chunk:

    this string followed by
    that string followed by
    another one string
    with that string
    at the very end.


But B<won't> pass for this chunk:

    that string followed by
    this string followed by
    another one string
    with that string
    at the very end.

C<begin:> C<end:> markers decorate `text blocks` content. C<:being|:end> markers should not be followed by any text at the same line.

Also be aware if you leave "dangling" C<begin:> marker without closing C<end>: somewhere else swat will remain in a `text block` mode 
till the end of your swat story, which is probably not you want:


    begin:
    here we begin
    and till the very end of test
    we are in `text block` mode


=over *

B<perl expressions>

Perl expressions are just a pieces of perl code to I<get evaled> by prove when executing swat stories. This is how it works:

    # this is my swat story
    200 OK
    code: print "hello world"
    That's OK



The piece of code above will be executed in two phases according to L</"Swat to Test::Harness Compilation"> specification:

First swat convert swat story into Test::Harness test:


    ok($status,"response matches 200 OK");
    eval 'print "hello world"';
    ok($status,"content matches That's OK"); # etc


Then prove execute a generated code. 

The example with 'print "hello world"' is quite meanignless, there any ways how you code use perl expressions in your swat stories, one of
obvious one, as swat depends on Test::More module is to leverages to some Test::More functions to adjust execution phase logic:


    # skip tests
    code: skip('next 3 checks are skipped',3) # skip three next checks forever
    color: red
    color: blue
    color: green

    number:one
    number:two
    number:three

    # skip tests under conditions

    color: red
    color: blue
    color: green

    code: skip('numbers checks are skipped',3)  if $ENV{'skip_numbers'} # skip three next checks if skip_numbers set 

    number:one
    number:two
    number:three



As you may noticed perl expressions are executed in a I<string eval> manner, please be aware of this.
Follow L<http://perldoc.perl.org/functions/eval.html> to get know about perl eval function.


=over *

B<generators>

Swat generators is the way to I<create swat check lists  on the fly>. Swat generators like perl expressions is just a piece of perl code 
executed the same way. The only difference with perl expressions is that swat generators code should return I<an array reference>.
An array returned by generator code should contain I<strings> representing new check list items. Thus new check list will passed back to swat
parser for dynamic check list generation. Here is a simple exmaple:


    # this is `static' check list
    200 OK
    HELLO
    
    # and this is simple swat generator
    # to append new items 
    # to the check list
    generator: [ qw{ foo bar baz } ]


    # the resulted check list will be
    200 OK
    HELLO
    foo
    bar
    baz


Generators entries start with C<:generator> marker. Here is more example:


    # you could you any perl constrution in generator code
    # unless it return an array reference
    generator: my %d = { 'foo' => 'foo value', 'bar' => 'bar value' }; [ map  { ( "# $_", "$data{$_}" )  } keys %d  ]


    # the resulted check list will be:

    # foo
    foo value
    # bar
    bar value


Writting generator code there is no limit for you! Use any code you want with only requirement - it should return array reference.

What about to validate web application content with sqlite database entries?

    generator:                                                          \

    use DBI;                                                            \
    my $dbh = DBI->connect("dbi:SQLite:dbname=t/data/test.db","","");   \
    my $sth = $dbh->prepare("SELECT name from users");                  \
    $sth->execute();                                                    \
    my $results = $sth->fetchall_arrayref;                              \

    [ map { $_->[0] } @${results} ]


Take a look at working example at examples/swat-generators-sqlite3 directory.


=over *

B<multiline expressions>

As long as swat deals with matchers ( both plain strings or regular expressions ) it works in a single line mode, that means
it does not make a sense about multilne strings here:

    200 OK
    Yet another strings
 
Often there is no need to operate on multiline string mode, as with the helo of text blocks matchers it is possible to express very
complicated matchers. But 



Sometimes code looks more readable when you split it on separate chunks. When swat parser meets  C<\> symbols it postpone entry execution and
add next line to buffer. This is repeated till no C<\> found on next. Finally swat execute I<"accumulated"> swat entity.

Here are some examples:

    # this is a generator
    # with multiline code
    generator:                  \
    my %d = {                   \
        'foo' => 'foo value',   \
        'bar' => 'bar value',   \
        'baz' => 'baz value'    \
    };                          \
    [                                               \
        map  { ( "# $_", "$data{$_}" )  } keys %d   \
    ]                                               \

    # this is also a generator
    # with a code consists of many lines
    generator: [            \
            map {           \
            uc($_)          \
        } qw( foo bar baz ) \
    ]

    code:                                                       \
    if $ENV{'debug'} == 1  { # conditionally skip this check    \
        skip('next test is skipped',1)                          \
    }
    HELLO SWAT

Multiline expressions are only allowable for perl expressions and generators.

=head3 Generators and Perl Expressions Scope

Swat uses I<perl string eval> when process generators and perl expressions code, be aware of this.

=head3 PERL5LIB

Swat adds B<$project_root_directory/lib> to PERL5LIB , so this is convenient convenient to place here custom perl modules:


    example/my-app/lib/Foo/Bar/Baz.pm

Take a look at examples/swat-generators-with-lib/ for working example


=head3 Captures

Captures are pieces of data get captured when swat match content against check expressions using I<regexps>:

    # here is content returned.
    # it is just my family ages.
    alex    38
    julia   25
    jan     2


    # here is swat data

    regexp: /(\w+)\s+(\d+)/


A check expression above will result in a captured data as perl array reference:

    [
        ['alex',    38 ]
        ['julia',   32 ]
        ['jan',     2  ]
    ]


Now captures might be accessed by code generators to get some extra checks:


    code:                               \
    my $total=0;                        \
    for my $c (@{captures()}) {         \
        $total+=$c->[0];                \
    }                                   \
    cmp_ok( $total,'==',72,"total age of my family" );


Thus perl expressions and code generators access captures data calling C<captures()> function.

Captures() returns an array reference holding all data captured during I<latest regexp check>.

Here some more examples:

    # check if output contains numbers
    # calculate total amount
    # it should be greater then ten

    regexp: (\d+)
    code:                               \
    my $total=0;                        \
    for my $c (@{captures()}) {         \
        $total+=$c->[0];                \
    }                                   \
    cmp_ok( $total,'>',10,"total amount is greater than 10" );


    # check if output contains lines
    # with date formatted as `date: YYYY-MM-DD`
    # check if first date found is yesterday

    regexp: date: (\d\d\d\d)-(\d\d)-(\d\d)
    code:                               \
    use DateTime;                       \
    my $c = captures()->[0];            \
    my $dt = DateTime->new( year => $c->[0], month => $c->[1], day => $c->[2]  ); \
    my $yesterday = DateTime->now->subtract( days =>  1 );     \
    cmp_ok( DateTime->compare($dt, $yesterday),'==',0,"first day found is - $dt and this is a yesterday" );


You also may use C<capture()> function to get a I<first element> of captures array:


    # check if output contains numbers
    # a first number should be greater then ten

    regexp: (\d+)
    code: cmp_ok( capture()->[0],'>',10,"first number is greater than 10" );


=head1 Anatomy of swat

Once swat runs it goes through some steps to get job done. Here is description of such a steps executed in orders

=head2 Run iterator over swat data files

Swat iterator look for all files named get.txt or post.txt or put.txt under project root directory. Actually this is simple bash find loop.

=head2 Parse swat data file

For every swat data file find by iterator parsing process starts. Swat parse data file line by line, at the end of such a process
I<a list of Test::More asserts> is generated. Finally asserts list and other input parameters are serialized as Test::More test scenario
written into into proper *.t file.

=head2 Give it a run by prove

Once swat finish parsing all the swat data files there is a whole bunch of *.t files kept under a designated  temporary directory,
thus every swat route maps into Test::More test file with the list of asserts. Now all is ready for prove run. Internally `prove -r `
command is issued to run tests and generate TAP report. That is it.


Below is example how this looks like

=head3 project structure


    $ tree examples/anatomy/
    examples/anatomy/
    |----FOO
    |-----|----BARs
    |           |---- post.txt
    |--- FOOs
          |--- get.txt

    3 directories, 2 files

=head3 swat data files

    # /FOOs
    FOO
    FOO2
    generator: | %w{ FOO3 FOO4 }|

    # /FOO/BARs
    BAR
    BAR2
    generator: | %w{ BAR3 BAR4 }|
    code: skip('skip next 2 tests',2);
    BAR5
    BAR6
    BAR7


=head3 Test::More Asserts list


    # /FOOs/0.t
    SKIP {
        ok($status, "successful response from GET $host/FOOs")
        ok($status, "GET /FOOs returns FOO")
        ok($status, "GET /FOOs returns FOO2")
        ok($status, "GET /FOOs returns FOO3")
        ok($status, "GET /FOOs returns FOO4")
    }

    # /FOO/BARs0.t
    SKIP {
        ok($status, "successful response from POST $host/FOO/BARs")
        ok($status, "POST /FOO/BARs returns BAR")
        ok($status, "POST /FOO/BARs returns BAR")
        ok($status, "POST /FOO/BARs returns BAR3")
        ok($status, "POST /FOO/BARs returns BAR4")
        skip('skip next 2 tests',2);
        ok($status, "POST /FOO/BARs returns BAR5")
        ok($status, "POST /FOO/BARs returns BAR6")
        ok($status, "POST /FOO/BARs returns BAR7")
    }


=head1 POST/PUT requests

Name swat data file as post.txt (put.txt) to make http POST (PUT) requests.

    echo 200 OK >> my-app/hello/post.txt
    echo 200 OK >> my-app/hello/world/post.txt

You may use curl_params setting ( follow L</"Swat Settings"> section for details ) to define post data, there are some examples:

=over

=item *

C<-d> - Post data sending by html form submit.


     # Place this in swat.ini file or sets as env variable:
     curl_params='-d name=daniel -d skill=lousy'


=item *

C<--data-binary> - Post data sending as is.


     # Place this in swat.ini file or sets as env variable:
     curl_params=`echo -E "--data-binary '{\"name\":\"alex\",\"last_name\":\"melezhik\"}'"`
     curl_params="${curl_params} -H 'Content-Type: application/json'"


=back


=head1 Swat Settings

Swat comes with settings defined in two contexts:

=over

=item *

Environment variables ( session settings )

=item *

swat.ini files ( home directory , project based, route based and custom settings  )


=back


=head2 Environment variables

Following variables define a proper swat settings.

=over

=item *

C<debug> - set to C<1,2> if you want to see some debug information in output, default value is C<0>

=item *

C<debug_bytes> - number of bytes of http response  to be dumped out when debug is on. default value is C<500>

=item *

C<swat_debug> - run swat in debug mode, default value is C<0>


=item *

C<ignore_http_err> - ignore http errors, if this parameters is off (set to C<1>) returned  I<error http codes> will not result in test fails,
useful when one need to test something with response differ from  2**,3** http codes. Default value is C<0>


=item *

C<try_num> - number of http requests  attempts before give it up ( useless for resources with slow response  ), default value is C<2>


=item *

C<curl_params> - additional curl parameters being add to http requests, default value is C<"">, follow curl documentation for variety of values for this


=item *

C<curl_connect_timeout> - follow curl documentation


=item *

C<curl_max_time> - follow curl documentation


=item *

C<port>  - http port of tested host, default value is C<80>

=item *

C<prove_options> - prove options, default value is C<-v>



=back


=head2 Swat.ini files

Swat checks files named C<swat.ini> in the following directories

=over

=item *

B<~/swat.ini> - home directory settings

=item *

B<$project_root_directory/swat.ini> -  project based settings

=item *

B<$route_directory/swat.ini> - route based settings

=item *

B<$cwd/swat.my> - custom settings

=back

Here are examples of locations of swat.ini files:


     ~/swat.ini # home directory settings
     my-app/swat.ini # project based settings
     my-app/hello/get.txt
     my-app/hello/swat.ini # route based settings ( route hello )
     my-app/hello/world/get.txt
     my-app/hello/world/swat.ini # route based settings ( route hello/world )


Once file exists at any location swat simply B<bash sources it> to apply settings.

Thus swat.ini file should be bash file with swat variables definitions. Here is example:

    # the content of swat.ini file:
    curl_params="-H 'Content-Type: text/html'"
    debug=1
    try_num=3

=head2 Settings priority table

This table describes all the settings with priority levels, the settings with higher priority are applied after settings
with lower priority.


    | context                 | location                   | settings type        | priority  level |
    | ------------------------|--------------------------- | -------------------- | --------------- |
    | swat.ini file           | ~/swat.ini                 | home directory       |       1         |
    | swat.ini file           | project root directory     | project based        |       2         |
    | swat.my  file           | current working directory  | custom settings      |       3         |
    | swat.ini file           | route directory            | route based          |       4         |
    | environment variables   | ---                        | session              |       5         |


=head1 Settings merge algorithm

Thus swat applies settings in order for every route:

=over

=item *

Home directory settings are applied if exist.

=item *

Project based settings are applied if exist.

=item *

Custom settings are applied if exist.

=item *

Route based settings are applied if exist.

=item *

And finally environment settings are applied if exist.

=back

=head2 Custom Settings

Custom settings are way to customize settings for existed swat package. This file should be located at current working directory,
where you run swat from. For example:

    # override http port
    $ echo port=8080 > swat.my
    $ swat swat::nginx 127.0.0.1

Follow section L<"Swat Packages"> to get more about portable swat tests.

=head1 Hooks

Hooks are extension points you may implement to hack into swat compile / runtime workflow. There are two types of hooks:

=over

=item *

Perl hooks

=item *

Bash Hooks

=back

=head2 Perl hooks

Perl hooks are files with perl code `required` I<in the beginning/end of a swat test>. There are four types of perl hooks:

=over

=item *

B<project based perl startup hook>

File located at C<$project_root_directory/hook.pm>.

Project based startup hooks are `required` I<in the beginning> of a swat test and applied for every route in project
and thus could be used for I<project initialization> procedures.

For example one could define common generators here:

    # place this in hook.pm file:
    sub list1 { | %w{ foo bar baz } | }
    sub list2 { | %w{ red green blue } | }


    # now we could use it in swat data file
    generator:  list()
    generator:  list2()

=item *

B<project based perl cleanup hook>

File located at C<$project_root_directory/cleanup.pm>.

This hooks is similar to startup hook but `required` I<in the end> of a swat test.

=item *

B<route based perl startup hooks>

Files located at C<$route_directory/hook.pm>.

Routes based startup hooks are applied for every route in project and thus could be used for I<route initialization> procedures.

For example one could define route specific generators here:


    # place this in hook.pm file:
    # notices that we could tell GET from POST http methods here
    # using predefined $method variable

    sub list1 {

        my $list;

        if ($method eq 'GET') {
            $list = | %w{ GET_foo GET_bar GET_baz } |
        }elsif($method eq 'POST'){
            $list = | %w{ POST_foo POST_bar POST_baz } |
        }else{
            die "method $method is not supported"
        }
        $list;
    }


    # now we could use it in swat data file
    generator:  list()


=item *

B<route based perl cleanup hooks>

Files located at C<$route_directory/cleanup.pm>.

This hooks is similar to route based startup hooks but `required` I<in the end> of a swat test.

=back

=head2 Bash hooks

Similar to perl hooks bash hooks are just a bash files `sourced` I<before compilation> of a swat test.

There are 4 types of bash hooks:

=over

=item *

B<project based bash hook>

File located at C<$project_root_directory/hook.bash>.

Project based bash hooks are applied for every route in project and could be used for I<project initialization> procedures.

=item *

B<route based bash hooks>

Files located at C<$project_root_directory/$route_directory/hook.bash>.

Routes based bash hooks are route specific hooks and could be used for I<route initialization> procedures.

=item *

B<global startup bash hook>

File located at C<$project_root_directory/startup.bash>.

Startup hook is executed before swat tests gets compiled, at the very beginning, at could be used for I<global initialization> procedures.


=item *

B<global cleanup bash hook>

File located at C<$project_root_directory/cleanup.bash>.

Cleanup hook is executed I<after swat tests are executed>, at the very end, and could be used for I<global cleanup> procedures.

=back

It is important to note that bash hooks are executed I<after swat settings merge done> , see  L<"Swat Settings"> section to get more
about swat settings.


=head2 Predefined variables

List of variables one may rely upon when writing perl/bash hooks:

=over

=item *

B<http_url>

=item *

B<curl_params>

=item *

B<http_meth> - C<GET|POST|HEAD>

=item *

B<route_dir>

=item *

B<project>

=back


=head1 Swat Compile and Runtime

 - Execute *global startup bash hook*
 - Start of swat compilation phase
 - For every route gets compiled:
    -- Merge swat settings
     -- Set predefined variables
     -- Execute *project based bash hook*
     -- Execute *route based bash hook*
     -- Compile route test
 - The end of swat compilation phase
 - Start of swat execution phase.
 - For every route test gets executed:
     -- Execute *project based perl startup hook*
     -- Execute *route based perl startup hook*
     -- Execute route test
     -- Execute *route based perl cleanup hook*
     -- Execute *project based perl cleanup hook*
 - The end of swat compilation phase
 - Execute *global cleanup bash hook*

=head1 TAP

Swat produces output in L<TAP|https://testanything.org/> format , that means you may use your favorite tap parsers to bring result to
another test / reporting systems, follow TAP documentation to get more on this. Here is example for converting swat tests into JUNIT format

    swat <project_root> <host> --formatter TAP::Formatter::JUnit


See also L<"Prove settings"> section.

=head1 Command line tool

Swat is shipped as cpan package, once it's installed ( see L</"Install"> section ) you have a command line tool called B<swat>, this is usage info on it:

    swat <project_root_dir|swat_package> <host:port> <prove settings>

=over

=item *

B<host> - is base url for web application you run tests against, you also have to define swat routes, see DSL section.


=item *

B<project_dir> - is a project root directory

=item *

B<swat_package> - the name of swat package, see L</"Swat Packages"> section


=back


=head2 Default Host

Sometimes it is helpful to not setup host as command line parameter but define it at $project_root/host file. For example:


    # let's create a default host for foo/bar project

    $ cat foo/bar/host
    foo.bar.com

    $ swat foo/bar/ # will run tests for foo.bar.com

=head2 Debugging

set C<swat_debug> environment variable to 1

=head2 Running a subset of tests

It is possible to run a subset of swat test setting a C<test_file> variable:

C<test_file>={unix file path} . Test_file path might be relative or absolute unix file path, internally swat just try to find all proper files using a trivial C<unix find>
construction:

    find $test_file -name  -type f -name get.txt -o -name post.txt -o -name put.txt

=head2 Prove settings

Swat utilize L<prove utility|http://search.cpan.org/perldoc?prove> to run tests, so all the swat options I<are passed as is to prove utility>.
Follow L<prove|http://search.cpan.org/perldoc?prove> utility documentation for variety of values you may set here.
Default value for prove options is  C<-v>. Here is another examples:

=over

=item *

C<-q -s> -  run tests in random and quite mode

=back


=head1 Swat Packages

Swat packages is portable archives of swat tests. It's easy to create your own swat packages and share with other.

This is mini how-to on creating swat packages:

=head2 Create swat package

Swat packages are I<just cpan modules>. So all you need is to create cpan module distribution archive and upload it to CPAN.

The only requirement for installer is that swat data files should be installed into I<cpan module directory> at the end of install process.
L<File::ShareDir::Install|http://search.cpan.org/perldoc?File%3A%3AShareDir%3A%3AInstall> allows you to install
read-only data files from a distribution and considered as best practice for such a things.

Here is example of Makefile.PL for L<swat::mongodb package|https://github.com/melezhik/swat-packages/tree/master/mongodb-http>:


    use inc::Module::Install;

    # Define metadata
    name           'swat-mongodb';
    all_from       'lib/swat/mongodb.pm';

    # Specific dependencies
    requires       'swat'         => '0.1.28';
    test_requires  'Test::More'   => '0';

    install_share  'module' => 'swat::mongodb', 'share';

    license 'perl';

    WriteAll;

Here we create a swat package swat::mongodb with swat data files kept in the project_root directory ./share and get installed into
C<auto/share/module/swat-mongodb> directory.


Once we uploaded a module to CPAN repository we can use it:

    $ cpan install swat::mongodb
    $ swat swat::mongodb 127.0.0.1:28017

Check out existed swat packages here - https://github.com/melezhik/swat-packages/


=head1 Examples

./examples directory contains examples of swat tests for different cases. Follow README.md files for details.

=head1 AUTHOR

L<Aleksei Melezhik|mailto:melezhik@gmail.com>


=head1 Home Page

https://github.com/melezhik/swat


=head1 Thanks

To the authors of ( see list ) without who swat would not appear to light

=over

=item *

perl

=item *

curl

=item *

TAP

=item *

Test::More

=item *

prove

=back

=head1 COPYRIGHT

Copyright 2015 Alexey Melezhik.

This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

